// Generated automatically from src/vm/wren_core.wren. Do not edit.
static const char* coreModuleSource =
"class Bool {}\n"
"class Fiber {}\n"
"class Fn {}\n"
"class Null {}\n"
"class Num {}\n"
"\n"
"class Algorithm {\n"
"  // Non-modifying sequence operations.\n"
"  static all(seq, unary_predicate) {\n"
"    var result = true\n"
"    for (element in seq) {\n"
"      result = unary_predicate.call(element)\n"
"      if (!result) return result\n"
"    }\n"
"    return result\n"
"  }\n"
"  \n"
"  static any(seq, unary_predicate) {\n"
"    var result = false\n"
"    for (element in seq) {\n"
"      result = unary_predicate.call(element)\n"
"      if (result) return result\n"
"    }\n"
"    return result\n"
"  }\n"
"  \n"
"  static contains(seq, element) {\n"
"    for (item in seq) {\n"
"      if (element == item) return true\n"
"    }\n"
"    return false\n"
"  }\n"
"  \n"
"  static count(seq) {\n"
"    var result = 0\n"
"    for (element in seq) {\n"
"      result = result + 1\n"
"    }\n"
"    return result\n"
"  }\n"
"\n"
"  static count(seq, unary_predicate) {\n"
"    var result = 0\n"
"    for (element in seq) {\n"
"      if (unary_predicate.call(element)) result = result + 1\n"
"    }\n"
"    return result\n"
"  }\n"
"  \n"
"  static each(seq, fn) {\n"
"    for (element in seq) {\n"
"      fn.call(element)\n"
"    }\n"
"  }\n"
"  \n"
"  static isEmpty(seq) { seq.iterate(null) ? false : true }\n"
"  \n"
"  // Modifying sequence operations.\n"
"  static copy(seq, res) {\n"
"    for (element in seq) {\n"
"      res.add(element)\n"
"    }\n"
"    return res\n"
"  }\n"
"  \n"
"  static copy(seq, res, unary_predicate) {\n"
"    for (element in seq) {\n"
"      if (unary_predicate.call(element)) res.add(element)\n"
"    }\n"
"    return res\n"
"  }\n"
"  \n"
"  // Views\n"
"  static filter(seq, unary_predicate)  { seq | View.filter(unary_predicate) }\n"
"  static transform(seq, fn)            { seq | View.transform(fn) }\n"
"  \n"
"  static skip(seq, count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"    return SkipSequence.new(seq, count)\n"
"  }\n"
"\n"
"  static take(seq, count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"    \n"
"    return TakeSequence.new(seq, count)\n"
"  }\n"
"  \n"
"  static where(seq, unary_predicate) { FilterSequenceView.new(seq, unary_predicate) }\n"
"  \n"
"  static reduce(seq, fn) {\n"
"    var iter = seq.iterate(null)\n"
"    if (!iter) Fiber.abort(\"Can't reduce an empty sequence.\")\n"
"    \n"
"    // Seed with the first element.\n"
"    var result = seq.iteratorValue(iter)\n"
"    while (iter = seq.iterate(iter)) {\n"
"      result = fn.call(result, seq.iteratorValue(iter))\n"
"    }\n"
"    return result\n"
"  }\n"
"  \n"
"  static reduce(seq, acc, fn) {\n"
"    for (element in seq) {\n"
"      acc = fn.call(acc, element)\n"
"    }\n"
"    return acc\n"
"  }\n"
"  \n"
"  static join(seq) { join(seq, \"\") }\n"
"  \n"
"  static join(seq, sep) {\n"
"    var first = true\n"
"    var result = \"\"\n"
"    \n"
"    for (element in seq) {\n"
"      if (!first) result = result + sep\n"
"      first = false\n"
"      result = result + element.toString\n"
"    }\n"
"    return result\n"
"  }\n"
"  \n"
"  static toList(seq) { Algorithm.copy(seq, List.new()) }\n"
"}\n"
"\n"
"class Sequence {\n"
"  | (view) { view.compose(this) }\n"
"\n"
"  all(unary_predicate)       { Algorithm.all(this, unary_predicate) }\n"
"  any(unary_predicate)       { Algorithm.any(this, unary_predicate) }\n"
"  contains(element)          { Algorithm.contains(this, element) }\n"
"  count                      { Algorithm.count(this) }\n"
"  count(unary_predicate)     { Algorithm.count(this, unary_predicate) }\n"
"  each(fn)                   { Algorithm.each(this, fn) }\n"
"  isEmpty                    { Algorithm.isEmpty(this) }\n"
"\n"
"  filter(unary_predicate)    { Algorithm.filter(this, unary_predicate) }\n"
"  transform(fn)              { Algorithm.transform(this, fn) }\n"
"\n"
"  map(transformation)        { transform(transformation) }\n"
"  skip(count)                { Algorithm.skip(this, count) }\n"
"  take(count)                { Algorithm.take(this, count) }\n"
"  where(unary_predicate)     { filter(unary_predicate) }\n"
"  reduce(fn)                 { Algorithm.reduce(this, fn) }\n"
"  reduce(acc, fn)            { Algorithm.reduce(this, acc, fn) }\n"
"\n"
"  join()                     { Algorithm.join(this) }\n"
"  join(sep)                  { Algorithm.join(this, sep) }\n"
"\n"
"  toList                     { Algorithm.toList(this) }\n"
"}\n"
"\n"
"class ViewedSequence is Sequence {\n"
"  construct new(seq, view) {\n"
"    _seq = seq\n"
"    _view = view\n"
"  }\n"
"  \n"
"  | (view) { view.compose(this) }\n"
"  \n"
"  iterate(iter) { _view.iterate(_seq, iter) }\n"
"  iteratorValue(iter) { _view.iteratorValue(_seq, iter) }\n"
"}\n"
"\n"
"class View {\n"
"  static filter(unary_predicate) { FilterView.new(unary_predicate) }\n"
"  static identity() { View.new() }\n"
"//  static remove_if(unary_predicate) { }\n"
"  static transform(fn) { TransformView.new(fn) }\n"
"  \n"
"  construct new() { } // Identity\n"
"  \n"
"  | (other) { ComposedView.new(this, other) }\n"
"  \n"
"  compose(seq) { ViewedSequence.new(seq, this) }\n"
"  \n"
"  iterate(seq, iter) { seq.iterate(iter) }\n"
"  iteratorValue(seq, iter) { seq.iteratorValue(iter) }\n"
"}\n"
"\n"
"class ComposedView is View {\n"
"  construct new (a, b) {\n"
"    _views = [a, b]\n"
"  }\n"
"  \n"
"  | (other) {\n"
"    _views.add(other)\n"
"    return this\n"
"  }\n"
"  \n"
"  compose(seq) {\n"
"    for (view in _views) seq = view.compose(seq)\n"
"    return seq\n"
"  }\n"
"}\n"
"\n"
"class FilterView is View {\n"
"  construct new(unary_predicate) {\n"
"    _unary_predicate = unary_predicate\n"
"  }\n"
"  \n"
"  compose(seq) { FilterSequenceView.new(seq, _unary_predicate) }\n"
"}\n"
"\n"
"class FilterSequenceView is Sequence {\n"
"  construct new(seq, unary_predicate) {\n"
"    _seq = seq\n"
"    _unary_predicate = unary_predicate\n"
"  }\n"
"  \n"
"  iterate(iter) {\n"
"    while (iter = _seq.iterate(iter)) {\n"
"      if (_unary_predicate.call(iteratorValue(iter))) return iter\n"
"    }\n"
"    return iter\n"
"  }\n"
"  iteratorValue(iter) { _seq.iteratorValue(iter) }\n"
"}\n"
"\n"
"class TransformView is View {\n"
"  construct new(fn) {\n"
"    _fn = fn\n"
"  }\n"
"  \n"
"  compose(seq) { TransformSequenceView.new(seq, _fn) }\n"
"}\n"
"\n"
"class TransformSequenceView is Sequence {\n"
"  construct new(seq, fn) {\n"
"    _seq = seq\n"
"    _fn = fn\n"
"  }\n"
"\n"
"  iterate(iterator) { _seq.iterate(iterator) }\n"
"  iteratorValue(iterator) { _fn.call(_seq.iteratorValue(iterator)) }\n"
"}\n"
"\n"
"class SkipSequence is Sequence {\n"
"  construct new(sequence, count) {\n"
"    _sequence = sequence\n"
"    _count = count\n"
"  }\n"
"\n"
"  iterate(iterator) {\n"
"    if (iterator) {\n"
"      return _sequence.iterate(iterator)\n"
"    } else {\n"
"      iterator = _sequence.iterate(iterator)\n"
"      var count = _count\n"
"      while (count > 0 && iterator) {\n"
"        iterator = _sequence.iterate(iterator)\n"
"        count = count - 1\n"
"      }\n"
"      return iterator\n"
"    }\n"
"  }\n"
"\n"
"  iteratorValue(iterator) { _sequence.iteratorValue(iterator) }\n"
"}\n"
"\n"
"class TakeSequence is Sequence {\n"
"  construct new(sequence, count) {\n"
"    _sequence = sequence\n"
"    _count = count\n"
"  }\n"
"\n"
"  iterate(iterator) {\n"
"    if (!iterator) _taken = 1 else _taken = _taken + 1\n"
"    return _taken > _count ? null : _sequence.iterate(iterator)\n"
"  }\n"
"\n"
"  iteratorValue(iterator) { _sequence.iteratorValue(iterator) }\n"
"}\n"
"\n"
"class String is Sequence {\n"
"  bytes { StringByteSequence.new(this) }\n"
"  codePoints { StringCodePointSequence.new(this) }\n"
"\n"
"  split(delimiter) {\n"
"    if (!(delimiter is String) || delimiter.isEmpty) {\n"
"      Fiber.abort(\"Delimiter must be a non-empty string.\")\n"
"    }\n"
"\n"
"    var result = []\n"
"\n"
"    var last = 0\n"
"    var index = 0\n"
"\n"
"    var delimSize = delimiter.byteCount_\n"
"    var size = byteCount_\n"
"\n"
"    while (last < size && (index = indexOf(delimiter, last)) != -1) {\n"
"      result.add(this[last...index])\n"
"      last = index + delimSize\n"
"    }\n"
"\n"
"    if (last < size) {\n"
"      result.add(this[last..-1])\n"
"    } else {\n"
"      result.add(\"\")\n"
"    }\n"
"    return result\n"
"  }\n"
"\n"
"  replace(from, to) {\n"
"    if (!(from is String) || from.isEmpty) {\n"
"      Fiber.abort(\"From must be a non-empty string.\")\n"
"    } else if (!(to is String)) {\n"
"      Fiber.abort(\"To must be a string.\")\n"
"    }\n"
"\n"
"    var result = \"\"\n"
"\n"
"    var last = 0\n"
"    var index = 0\n"
"\n"
"    var fromSize = from.byteCount_\n"
"    var size = byteCount_\n"
"\n"
"    while (last < size && (index = indexOf(from, last)) != -1) {\n"
"      result = result + this[last...index] + to\n"
"      last = index + fromSize\n"
"    }\n"
"\n"
"    if (last < size) result = result + this[last..-1]\n"
"\n"
"    return result\n"
"  }\n"
"\n"
"  *(count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"\n"
"    var result = \"\"\n"
"    for (i in 0...count) {\n"
"      result = result + this\n"
"    }\n"
"    return result\n"
"  }\n"
"}\n"
"\n"
"class StringByteSequence is Sequence {\n"
"  construct new(string) {\n"
"    _string = string\n"
"  }\n"
"\n"
"  [index] { _string.byteAt_(index) }\n"
"  iterate(iterator) { _string.iterateByte_(iterator) }\n"
"  iteratorValue(iterator) { _string.byteAt_(iterator) }\n"
"\n"
"  count { _string.byteCount_ }\n"
"}\n"
"\n"
"class StringCodePointSequence is Sequence {\n"
"  construct new(string) {\n"
"    _string = string\n"
"  }\n"
"\n"
"  [index] { _string.codePointAt_(index) }\n"
"  iterate(iterator) { _string.iterate(iterator) }\n"
"  iteratorValue(iterator) { _string.codePointAt_(iterator) }\n"
"\n"
"  count { _string.count }\n"
"}\n"
"\n"
"class List is Sequence {\n"
"  addAll(other) {\n"
"    for (element in other) {\n"
"      add(element)\n"
"    }\n"
"    return other\n"
"  }\n"
"\n"
"  toString { \"[%(join(\", \"))]\" }\n"
"\n"
"  +(other) {\n"
"    var result = this[0..-1]\n"
"    for (element in other) {\n"
"      result.add(element)\n"
"    }\n"
"    return result\n"
"  }\n"
"\n"
"  *(count) {\n"
"    if (!(count is Num) || !count.isInteger || count < 0) {\n"
"      Fiber.abort(\"Count must be a non-negative integer.\")\n"
"    }\n"
"\n"
"    var result = []\n"
"    for (i in 0...count) {\n"
"      result.addAll(this)\n"
"    }\n"
"    return result\n"
"  }\n"
"}\n"
"\n"
"class Map is Sequence {\n"
"  keys { MapKeySequence.new(this) }\n"
"  values { MapValueSequence.new(this) }\n"
"\n"
"  toString {\n"
"    var first = true\n"
"    var result = \"{\"\n"
"\n"
"    for (key in keys) {\n"
"      if (!first) result = result + \", \"\n"
"      first = false\n"
"      result = result + \"%(key): %(this[key])\"\n"
"    }\n"
"\n"
"    return result + \"}\"\n"
"  }\n"
"\n"
"  iteratorValue(iterator) {\n"
"    return MapEntry.new(\n"
"        keyIteratorValue_(iterator),\n"
"        valueIteratorValue_(iterator))\n"
"  }\n"
"}\n"
"\n"
"class MapEntry {\n"
"  construct new(key, value) {\n"
"    _key = key\n"
"    _value = value\n"
"  }\n"
"\n"
"  key { _key }\n"
"  value { _value }\n"
"\n"
"  toString { \"%(_key):%(_value)\" }\n"
"}\n"
"\n"
"class MapKeySequence is Sequence {\n"
"  construct new(map) {\n"
"    _map = map\n"
"  }\n"
"\n"
"  iterate(n) { _map.iterate(n) }\n"
"  iteratorValue(iterator) { _map.keyIteratorValue_(iterator) }\n"
"}\n"
"\n"
"class MapValueSequence is Sequence {\n"
"  construct new(map) {\n"
"    _map = map\n"
"  }\n"
"\n"
"  iterate(n) { _map.iterate(n) }\n"
"  iteratorValue(iterator) { _map.valueIteratorValue_(iterator) }\n"
"}\n"
"\n"
"class Range is Sequence {}\n"
"\n"
"class System {\n"
"  static print() {\n"
"    writeString_(\"\n\")\n"
"  }\n"
"\n"
"  static print(obj) {\n"
"    writeObject_(obj)\n"
"    writeString_(\"\n\")\n"
"    return obj\n"
"  }\n"
"\n"
"  static printAll(sequence) {\n"
"    for (object in sequence) writeObject_(object)\n"
"    writeString_(\"\n\")\n"
"  }\n"
"\n"
"  static write(obj) {\n"
"    writeObject_(obj)\n"
"    return obj\n"
"  }\n"
"\n"
"  static writeAll(sequence) {\n"
"    for (object in sequence) writeObject_(object)\n"
"  }\n"
"\n"
"  static writeObject_(obj) {\n"
"    var string = obj.toString\n"
"    if (string is String) {\n"
"      writeString_(string)\n"
"    } else {\n"
"      writeString_(\"[invalid toString]\")\n"
"    }\n"
"  }\n"
"}\n";
